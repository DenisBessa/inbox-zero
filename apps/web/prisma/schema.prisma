generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Account {
  id                String        @id @default(cuid())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  userId            String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  expires_at        DateTime?     @default(now())
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccount      EmailAccount?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  ipAddress    String?
  userAgent    String?
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                       String         @id @default(cuid())
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  name                     String?
  email                    String         @unique
  image                    String?
  completedOnboardingAt    DateTime?
  completedAppOnboardingAt DateTime?
  onboardingAnswers        Json?
  lastLogin                DateTime?
  utms                     Json?
  errorMessages            Json?
  surveyFeatures           String[]
  surveyRole               String?
  surveyGoal               String?
  surveySource             String?
  surveyImprovements       String?
  aiProvider               String?
  aiModel                  String?
  aiApiKey                 String?
  webhookSecret            String?
  referralCode             String?        @unique
  premiumId                String?
  premiumAdminId           String?
  emailVerified            Boolean        @default(false)
  accounts                 Account[]
  apiKeys                  ApiKey[]
  emailAccounts            EmailAccount[]
  referralReceived         Referral?      @relation("ReferredUser")
  referralsMade            Referral[]     @relation("ReferrerUser")
  sessions                 Session[]
  premiumAdmin             Premium?       @relation(fields: [premiumAdminId], references: [id])
  premium                  Premium?       @relation("userPremium", fields: [premiumId], references: [id])
}

model EmailAccount {
  id                        String            @id @default(cuid())
  email                     String            @unique
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  name                      String?
  image                     String?
  about                     String?
  writingStyle              String?
  signature                 String?
  watchEmailsExpirationDate DateTime?
  watchEmailsSubscriptionId String?
  lastSyncedHistoryId       String?
  behaviorProfile           Json?
  statsEmailFrequency       Frequency         @default(WEEKLY)
  summaryEmailFrequency     Frequency         @default(WEEKLY)
  lastSummaryEmailAt        DateTime?
  coldEmailBlocker          ColdEmailSetting?
  coldEmailDigest           Boolean           @default(false)
  coldEmailPrompt           String?
  rulesPrompt               String?
  outboundReplyTracking     Boolean           @default(false)
  autoCategorizeSenders     Boolean           @default(false)
  userId                    String
  accountId                 String            @unique
  categories                Category[]
  chats                     Chat[]
  cleanupJobs               CleanupJob[]
  cleanupThreads            CleanupThread[]
  coldEmails                ColdEmail[]
  digests                   Digest[]
  account                   Account           @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user                      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailMessages             EmailMessage[]
  emailTokens               EmailToken[]
  executedRules             ExecutedRule[]
  groups                    Group[]
  knowledge                 Knowledge[]
  labels                    Label[]
  newsletters               Newsletter[]
  rules                     Rule[]
  digestSchedule            Schedule?
  scheduledActions          ScheduledAction[]
  threadTrackers            ThreadTracker[]

  @@index([lastSummaryEmailAt])
}

model Digest {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  emailAccountId String
  sentAt         DateTime?
  status         DigestStatus @default(PENDING)
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  items          DigestItem[]

  @@index([emailAccountId])
}

model DigestItem {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  messageId   String
  threadId    String
  content     String
  digestId    String
  actionId    String?
  coldEmailId String?
  action      ExecutedAction? @relation(fields: [actionId], references: [id])
  coldEmail   ColdEmail?      @relation(fields: [coldEmailId], references: [id])
  digest      Digest          @relation(fields: [digestId], references: [id], onDelete: Cascade)

  @@unique([digestId, threadId, messageId])
}

model Schedule {
  id               String       @id @default(cuid())
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  intervalDays     Int?
  occurrences      Int?
  daysOfWeek       Int?
  timeOfDay        DateTime?
  emailAccountId   String       @unique
  lastOccurrenceAt DateTime?
  nextOccurrenceAt DateTime?
  emailAccount     EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
}

model Premium {
  id                             String       @id @default(cuid())
  createdAt                      DateTime     @default(now())
  updatedAt                      DateTime     @updatedAt
  pendingInvites                 String[]
  lemonSqueezyRenewsAt           DateTime?
  lemonSqueezyCustomerId         Int?
  lemonSqueezySubscriptionId     Int?
  lemonSqueezySubscriptionItemId Int?
  lemonSqueezyOrderId            Int?
  lemonSqueezyProductId          Int?
  lemonSqueezyVariantId          Int?
  lemonLicenseKey                String?
  lemonLicenseInstanceId         String?
  lemonSubscriptionStatus        String?
  stripeCustomerId               String?      @unique
  stripeSubscriptionId           String?      @unique
  stripeSubscriptionItemId       String?      @unique
  stripePriceId                  String?
  stripeProductId                String?
  stripeSubscriptionStatus       String?
  stripeCancelAtPeriodEnd        Boolean?
  stripeRenewsAt                 DateTime?
  stripeTrialEnd                 DateTime?
  stripeCanceledAt               DateTime?
  stripeEndedAt                  DateTime?
  tier                           PremiumTier?
  emailAccountsAccess            Int?
  unsubscribeMonth               Int?
  unsubscribeCredits             Int?
  aiMonth                        Int?
  aiCredits                      Int?
  payments                       Payment[]
  admins                         User[]
  users                          User[]       @relation("userPremium")

  @@index([pendingInvites])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())
  id         String   @id @default(cuid())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, token])
}

model Label {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  gmailLabelId   String
  name           String
  description    String?
  enabled        Boolean      @default(true)
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([gmailLabelId, emailAccountId])
  @@unique([name, emailAccountId])
}

model Rule {
  id                  String              @id @default(cuid())
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  name                String
  enabled             Boolean             @default(true)
  automate            Boolean             @default(false)
  runOnThreads        Boolean             @default(false)
  emailAccountId      String
  conditionalOperator LogicalOperator     @default(AND)
  instructions        String?
  groupId             String?             @unique
  from                String?
  to                  String?
  subject             String?
  body                String?
  categoryFilterType  CategoryFilterType?
  systemType          SystemType?
  promptText          String?
  actions             Action[]
  executedRules       ExecutedRule[]
  emailAccount        EmailAccount        @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  group               Group?              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  history             RuleHistory[]
  categoryFilters     Category[]          @relation("CategoryToRule")

  @@unique([name, emailAccountId])
  @@unique([emailAccountId, systemType])
}

model Action {
  id             String     @id @default(cuid())
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  type           ActionType
  ruleId         String
  label          String?
  subject        String?
  content        String?
  to             String?
  cc             String?
  bcc            String?
  url            String?
  delayInMinutes Int?
  rule           Rule       @relation(fields: [ruleId], references: [id], onDelete: Cascade)
}

model RuleHistory {
  id                  String   @id @default(cuid())
  createdAt           DateTime @default(now())
  ruleId              String
  version             Int
  triggerType         String
  promptText          String?
  name                String
  instructions        String?
  enabled             Boolean
  automate            Boolean
  runOnThreads        Boolean
  conditionalOperator String
  from                String?
  to                  String?
  subject             String?
  body                String?
  categoryFilterType  String?
  systemType          String?
  actions             Json
  categoryFilters     Json?
  rule                Rule     @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@unique([ruleId, version])
  @@index([ruleId, createdAt])
}

model ExecutedRule {
  id               String             @id @default(cuid())
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  threadId         String
  messageId        String
  status           ExecutedRuleStatus
  automated        Boolean
  reason           String?
  ruleId           String?
  emailAccountId   String
  actionItems      ExecutedAction[]
  emailAccount     EmailAccount       @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  rule             Rule?              @relation(fields: [ruleId], references: [id])
  scheduledActions ScheduledAction[]

  @@unique([emailAccountId, threadId, messageId], name: "unique_emailAccount_thread_message")
  @@index([emailAccountId, status, createdAt])
}

model ExecutedAction {
  id              String           @id @default(cuid())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  type            ActionType
  executedRuleId  String
  label           String?
  subject         String?
  content         String?
  to              String?
  cc              String?
  bcc             String?
  url             String?
  draftId         String?
  wasDraftSent    Boolean?
  digestItems     DigestItem[]
  draftSendLog    DraftSendLog?
  executedRule    ExecutedRule     @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
  scheduledAction ScheduledAction?
}

model ScheduledAction {
  id               String                @id @default(cuid())
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  executedRuleId   String
  actionType       ActionType
  messageId        String
  threadId         String
  scheduledFor     DateTime
  emailAccountId   String
  status           ScheduledActionStatus @default(PENDING)
  schedulingStatus SchedulingStatus      @default(PENDING)
  label            String?
  subject          String?
  content          String?
  to               String?
  cc               String?
  bcc              String?
  url              String?
  scheduledId      String?
  executedAt       DateTime?
  executedActionId String?               @unique
  emailAccount     EmailAccount          @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  executedAction   ExecutedAction?       @relation(fields: [executedActionId], references: [id])
  executedRule     ExecutedRule          @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)

  @@index([status, scheduledFor])
  @@index([emailAccountId, messageId])
}

model Group {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  name           String
  prompt         String?
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  items          GroupItem[]
  rule           Rule?

  @@unique([name, emailAccountId])
}

model GroupItem {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  groupId   String?
  type      GroupItemType
  value     String
  exclude   Boolean       @default(false)
  group     Group?        @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, type, value])
}

model Category {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  name           String
  description    String?
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  emailSenders   Newsletter[]
  rules          Rule[]       @relation("CategoryToRule")

  @@unique([name, emailAccountId])
}

model Newsletter {
  id              String            @id @default(cuid())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  email           String
  status          NewsletterStatus?
  patternAnalyzed Boolean           @default(false)
  lastAnalyzedAt  DateTime?
  emailAccountId  String
  categoryId      String?
  category        Category?         @relation(fields: [categoryId], references: [id])
  emailAccount    EmailAccount      @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([email, emailAccountId])
  @@index([emailAccountId, status])
}

model ColdEmail {
  id             String           @id @default(cuid())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  fromEmail      String
  messageId      String?
  threadId       String?
  status         ColdEmailStatus?
  reason         String?
  emailAccountId String
  emailAccount   EmailAccount     @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  digestItems    DigestItem[]

  @@unique([emailAccountId, fromEmail])
  @@index([emailAccountId, status])
  @@index([emailAccountId, createdAt])
}

model EmailMessage {
  id              String       @id @default(cuid())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  threadId        String
  messageId       String
  date            DateTime
  from            String
  fromDomain      String
  to              String
  unsubscribeLink String?
  read            Boolean
  sent            Boolean
  draft           Boolean
  inbox           Boolean
  emailAccountId  String
  emailAccount    EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, threadId, messageId])
  @@index([emailAccountId, threadId])
  @@index([emailAccountId, date])
  @@index([emailAccountId, from])
}

model ThreadTracker {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  sentAt         DateTime
  threadId       String
  messageId      String
  resolved       Boolean           @default(false)
  type           ThreadTrackerType
  emailAccountId String
  emailAccount   EmailAccount      @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, threadId, messageId])
  @@index([emailAccountId, resolved])
  @@index([emailAccountId, resolved, sentAt, type])
  @@index([emailAccountId, type, resolved, sentAt])
}

model CleanupJob {
  id               String          @id @default(cuid())
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  action           CleanAction     @default(ARCHIVE)
  daysOld          Int             @default(7)
  instructions     String?
  skipReply        Boolean?
  skipStarred      Boolean?
  skipCalendar     Boolean?
  skipReceipt      Boolean?
  skipAttachment   Boolean?
  skipConversation Boolean?
  emailAccountId   String
  emailAccount     EmailAccount    @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  threads          CleanupThread[]
}

model CleanupThread {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  threadId       String
  archived       Boolean
  jobId          String
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  job            CleanupJob   @relation(fields: [jobId], references: [id], onDelete: Cascade)
}

model Knowledge {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  title          String
  content        String
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, title])
}

model ApiKey {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  hashedKey String   @unique
  isActive  Boolean  @default(true)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
}

model EmailToken {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  token          String       @unique
  expiresAt      DateTime
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
}

model Payment {
  id                      String        @id @default(cuid())
  createdAt               DateTime
  updatedAt               DateTime
  premiumId               String?
  processorType           ProcessorType @default(LEMON_SQUEEZY)
  processorId             String?       @unique
  processorSubscriptionId String?
  processorCustomerId     String?
  amount                  Int
  currency                String
  status                  String
  tax                     Int
  taxInclusive            Boolean
  refunded                Boolean       @default(false)
  refundedAt              DateTime?
  refundedAmount          Int?
  billingReason           String?
  premium                 Premium?      @relation(fields: [premiumId], references: [id])
}

model DraftSendLog {
  id               String         @id @default(cuid())
  createdAt        DateTime       @default(now())
  executedActionId String         @unique
  sentMessageId    String
  similarityScore  Float
  executedAction   ExecutedAction @relation(fields: [executedActionId], references: [id], onDelete: Cascade)

  @@index([executedActionId])
}

model Chat {
  id             String        @id @default(cuid())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  emailAccountId String
  emailAccount   EmailAccount  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  messages       ChatMessage[]

  @@index([emailAccountId])
}

model ChatMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String
  parts     Json
  chatId    String
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId])
}

model Referral {
  id                         String         @id @default(cuid())
  createdAt                  DateTime       @default(now())
  updatedAt                  DateTime       @updatedAt
  referrerUserId             String
  referredUserId             String         @unique
  referralCodeUsed           String
  status                     ReferralStatus @default(PENDING)
  rewardGrantedAt            DateTime?
  stripeBalanceTransactionId String?
  rewardAmount               Int?
  referredUser               User           @relation("ReferredUser", fields: [referredUserId], references: [id], onDelete: Cascade)
  referrerUser               User           @relation("ReferrerUser", fields: [referrerUserId], references: [id], onDelete: Cascade)

  @@index([referrerUserId])
  @@index([status])
}

enum ActionType {
  ARCHIVE
  LABEL
  REPLY
  SEND_EMAIL
  FORWARD
  DRAFT_EMAIL
  MARK_SPAM
  CALL_WEBHOOK
  MARK_READ
  TRACK_THREAD
  DIGEST
}

enum Frequency {
  NEVER
  DAILY
  WEEKLY
}

enum NewsletterStatus {
  APPROVED
  UNSUBSCRIBED
  AUTO_ARCHIVED
}

enum ColdEmailStatus {
  AI_LABELED_COLD
  USER_REJECTED_COLD
}

enum ColdEmailSetting {
  DISABLED
  LIST
  LABEL
  ARCHIVE_AND_LABEL
  ARCHIVE_AND_READ_AND_LABEL
}

enum PremiumTier {
  BASIC_MONTHLY
  BASIC_ANNUALLY
  PRO_MONTHLY
  PRO_ANNUALLY
  BUSINESS_MONTHLY
  BUSINESS_ANNUALLY
  BUSINESS_PLUS_MONTHLY
  BUSINESS_PLUS_ANNUALLY
  COPILOT_MONTHLY
  LIFETIME
}

enum ExecutedRuleStatus {
  APPLIED
  APPLYING
  REJECTED
  PENDING
  SKIPPED
  ERROR
}

enum GroupItemType {
  FROM
  SUBJECT
  BODY
}

enum CategoryFilterType {
  INCLUDE
  EXCLUDE
}

enum LogicalOperator {
  AND
  OR
}

enum ThreadTrackerType {
  AWAITING
  NEEDS_REPLY
  NEEDS_ACTION
}

enum ProcessorType {
  LEMON_SQUEEZY
  STRIPE
}

enum CleanAction {
  ARCHIVE
  MARK_READ
}

enum SystemType {
  TO_REPLY
  NEWSLETTER
  MARKETING
  CALENDAR
  RECEIPT
  NOTIFICATION
}

enum ReferralStatus {
  PENDING
  COMPLETED
}

enum DigestStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
}

enum ScheduledActionStatus {
  PENDING
  EXECUTING
  COMPLETED
  FAILED
  CANCELLED
}

enum SchedulingStatus {
  PENDING
  SCHEDULED
  FAILED
}
